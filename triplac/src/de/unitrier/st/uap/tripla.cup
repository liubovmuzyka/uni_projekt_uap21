
// Preliminary Declarations Section ===========================================

package de.unitrier.st.uap;

import java_cup.runtime.Scanner;
import java_cup.runtime.Symbol;
import de.unitrier.st.uap.nodes.*;

parser code
    {:

    /*
     * Extended error reporting with line and column numbers
     * provided by the given Symbol object
     */
    public void report_error(String message, Object info)
    {
        String str = "Error";

        if (info instanceof Symbol)
        {
            Symbol symbol = ((Symbol) info);

            if (symbol.left >= 0)
            {
                str += " at line " + (symbol.left+1);

                if (symbol.right >= 0)
                {
                    str += ", column " + (symbol.right+1);
                }
            }
            
            str += ", " + symbol.value;
        }

        str += " : " + message;

        System.err.println(str);
    }


    /*
     * Extended fatal error reporting with line and column numbers
     * provided by the given Symbol object
     */
    public void report_fatal_error(String message, Object info)
    {
        report_error(message, info);
        System.exit(1);
    }

    :};


// Declaration of Terminals and Non Terminals =================================

terminal Symbol LET, IN, IF, THEN, ELSE, WHILE, DO;
terminal Symbol STARTBR, ENDBR, STARTCB, ENDCB, SEMI, COMMA, ASSIGN;
terminal Symbol EQEQ, NEQ, LT, GT, GOE, LOE, AND, OR;
terminal Symbol PLUS, MIN, DIV, MULT;
terminal String ID;
terminal Integer CONST;
terminal Symbol TRUE, FALSE;

non terminal Node E, D, A, EXP, V;

/* Precedences */
precedence nonassoc ENDBR, ENDCB;
precedence left COMMA, SEMI, ID;
precedence nonassoc ASSIGN, ELSE;
//precedence left LET, IN, IF, THEN, ELSE, WHILE, DO;
precedence nonassoc EQEQ, NEQ, LT, GT, GOE, LOE;
precedence left PLUS, MIN, OR;
precedence left MULT, DIV, AND;

// Grammar Section ===========================================================

/*
E ::= LET D IN E
    | ID
    | ID STARTBR A ENDBR
    | E AOP E
    | STARTBR E ENDBR
    | CONST
    | BIN
    | ID EQ E
    | E SEMI E
    | IF EXP THEN E ELSE E
    | WHILE EXP DO STARTCB E ENDCB
    ;

EXP::= BIN
    | STARTBR EXP ENDBR
    | E RELOP E
    | EXP LOP EXP
    ;

A ::= E
    | A COMMA E
    ;

D ::= ID STARTBR V ENDBR STARTCB E ENDCB
    | D D
    ;

V ::= ID
    | V COMMA V
    ;

*/

start with E;

E ::= LET D:d IN E:e
    {:
        System.out.println("Let");
        Node node = new LetNode();
        node.addChild(d);
        node.addChild(e);
        RESULT = node;
    :}
    | ID:id
    {:
        System.out.println("ID");
        Node node = new IdentifierNode(id);
        RESULT = node;
    :}
    | ID:id STARTBR A:a ENDBR
    {:
        System.out.println("CALL");
        Node node = new CallNode();
        node.addChild(new IdentifierNode(id));
        node.addChild(a);
        RESULT = node;
    :}
    | E:e1 PLUS E:e2
    {:
    System.out.println("PLUS");
        Node node = new OpNode("+");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 MIN E:e2
    {:
    System.out.println("MIN");
        Node node = new OpNode("-");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 DIV E:e2
    {:
    System.out.println("DIV");
        Node node = new OpNode("/");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 MULT E:e2
    {:
    System.out.println("MUL");
        Node node = new OpNode("*");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | STARTBR E:e ENDBR
    {:
    System.out.println("(E)");
        Node node = new InBrNode();
        node.addChild(e);
        RESULT = node;
    :}
    | CONST:c
    {:
    System.out.println("CONST");
        RESULT = new ConstNode(c);
    :}
/*    | BIN:bin
    {:
    System.out.println("BIN");
        //RESULT = new BinNode(bin.value);
        RESULT = new BinNode(bin);
    :}
    */
    | ID:id ASSIGN E:e
    {:
    System.out.println("ASSIGN");
        Node node = new SetNode();
        node.addChild(new IdentifierNode(id));
        node.addChild(e);
        RESULT = node;
    :}
    | E:e1 SEMI E:e2
    {:
    System.out.println("SEMI");
        Node node = new SemiNode();
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | IF EXP:exp THEN E:e1 ELSE E:e2
    {:
        System.out.println("IF");
        Node node = new IfNode();
        node.addChild(exp);
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | WHILE EXP:exp DO STARTCB E:e1 ENDCB
    {:
    System.out.println("WHILE");
        Node node = new WhileNode();
        node.addChild(exp);
        node.addChild(e1);
        RESULT = node;
    :}
    ;

EXP ::= TRUE
    {:
        RESULT = new ConstNode(1);
    :}
    | FALSE
    {:
        RESULT = new ConstNode(0);
    :}
  /*  |
    STARTBR EXP:exp ENDBR
    {:
    System.out.println("(true/false)");
        Node node = new InBrNode();
       // node.addChild(new BinNode(bin.value));
        node.addChild(new BinNode(exp));
        RESULT = node;
    :} */
    | STARTBR EXP:exp ENDBR
    {:
    System.out.println("(C)");
        Node node = new InBrNode();
        node.addChild(exp);
        RESULT = node;
    :}
    | E:e1 EQEQ E:e2
    {:
    System.out.println("E == E");
        Node node = new OpNode("==");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 NEQ E:e2
    {:
    System.out.println("E != E");
        Node node = new OpNode("!=");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 LT E:e2
    {:
    System.out.println("E < E");
        Node node = new OpNode("<");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 GT E:e2
    {:
    System.out.println("E > E");
        Node node = new OpNode(">");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 GOE E:e2
    {:
    System.out.println("E >= E");
        Node node = new OpNode(">=");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | E:e1 LOE E:e2
    {:
    System.out.println("E <= E");
        Node node = new OpNode("<=");
        node.addChild(e1);
        node.addChild(e2);
        RESULT = node;
    :}
    | EXP:exp1 EQEQ EXP:exp2
    {:
    System.out.println("C == C");
        Node node = new OpNode("==");
        node.addChild(exp1);
        node.addChild(exp2);
        RESULT = node;
    :}
    | EXP:exp1 NEQ EXP:exp2
    {:
    System.out.println("C != C");
        Node node = new OpNode("!=");
        node.addChild(exp1);
        node.addChild(exp2);
        RESULT = node;
    :}
    | EXP:exp1 AND EXP:exp2
    {:
    System.out.println("C AND C");
        Node node = new OpNode("&&");
        node.addChild(exp1);
        node.addChild(exp2);
        RESULT = node;
    :}
    | EXP:exp1 OR EXP:exp2
    {:
    System.out.println("C OR C");
        Node node = new OpNode("||");
        node.addChild(exp1);
        node.addChild(exp2);
        RESULT = node;
    :}
    ;

A ::= E:e1
    {:
    System.out.println("A");
        RESULT = e1;
    :}
    | A:a1 COMMA E:e1
    {:
    System.out.println("A COMMA");
        Node node = new CommaNode();
        node.addChild(a1);
        node.addChild(e1);
        RESULT = node;
    :}
    ;

D ::= ID:id STARTBR V:v ENDBR STARTCB E:e ENDCB
    {:
    System.out.println("DEF");
        Node node = new DefinitionNode();
        node.addChild(new IdentifierNode(id));
        node.addChild(v);
        node.addChild(e);
        RESULT = node;
    :}
    | D:d1 D:d2
    {:
    System.out.println("D D");
        Node node = new DefDefNode();
        node.addChild(d1);
        node.addChild(d2);
        RESULT = node;
    :}
    ;

V ::= ID:id
    {:
    System.out.println("V");
        Node node = new IdentifierNode(id);
        RESULT = node;
    :}
    | V:v1 COMMA V:v2
    {:
    System.out.println("V, V");
        Node node = new CommaNode();
        node.addChild(v1);
        node.addChild(v2);
        RESULT = node;
    :}
    ;